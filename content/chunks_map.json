{
  "0": {
    "id": "40028b01-c4b1-4925-b20a-357381016ebd",
    "source_file": "README_s21_decimal.md",
    "section": "s21_decimal",
    "content": "> При старте работы над проектом просим вас постараться хронометрировать время работы над проектом.\n> По завершении работы над проектом просим вас ответить на два вопроса в этом опросе\n\nImplementation of your own s21_decimal.h library.\n\nThe russian version of the task can be found in the repository."
  },
  "1": {
    "id": "9aec12ff-84f4-4e87-bfb8-56847b9ab328",
    "source_file": "README_s21_decimal.md",
    "section": "Contents",
    "content": "1. Chapter I \\\n   1.1. Introduction\n2. Chapter II \\\n   2.1. Information\n3. Chapter III \\\n   3.1. Part 1"
  },
  "2": {
    "id": "8a70e8ee-5636-4f59-b7e0-714663a1053c",
    "source_file": "README_s21_decimal.md",
    "section": "Chapter I",
    "content": "!s21_decimal\n\nPlanet Earth, 1990s. \n\nThe world economy is growing exponentially, the stock exchange increases many times year after year, more and more companies go public and their shares start to be quoted. The number of users, the number of transactions, price, commission, interest, calculation of financial technical indicators... It's hard to overestimate the accuracy of all this data, and there are serious problems with the current obsolete data types used in the financial sector.\n\nDue to a calculation error in the usual IEEE 754 (float) millions of dollars are lost every year, which simply absorbed from the system, disappearing forever. \n\nTogether with the FIX (Financial Information eXchange) protocol, which is being developed for data processing in the transfer between the broker and the exchange, one more tool is needed for data transfer and storage. \\\nAt the follow-up meeting:\n\n-- So, gentlemen, please note that our group of specialists, who have already proven themselves in many successful projects, has been tasked by the government to develop a completely new type of data, code-named Decimal. Its task is to allow significantly minimise error for several decades, and in some cases remove it completely in the world's financial transactions. It is required to describe all the necessary logical and arithmetic operations, which would allow to make the necessary calculations quickly and conveniently.\n\n- Wow, that's quite an order we got, and from such a customer! We have to keep this client - it promises us big contracts in the future if we do well!\n\n-- Yes, you're right, that’s why we need to figure out what functions we need to implement... Any suggestions?\n\n-- Sum and difference....\n\n-- Multiplication and division...\n\n-- Agreed, but we need more!\n\n- Taking the remainder, comparison and conversion operations!\n\n-- Mathematical rounding in all directions!\n\n-- Yes, I think that’s enough, let’s get to work! We've got no more than a couple of days, don't let us down!"
  },
  "3": {
    "id": "7c81e4bf-0ba1-4bc0-b6f8-b52a416e9054",
    "source_file": "README_s21_decimal.md",
    "section": "Introduction",
    "content": "In this project you will implement the s21_decimal.h library in the C programming language. This library should add the ability to work with the \"decimal\" type, which is not in the language standard. Nevertheless, this type is critically important. For financial calculations, for example, where errors of calculations characteristic of types with floating point are unacceptable. As part of the project you will work with the tasks of processing financial information, dive into the issues of internal representation of different types of data, and solidify knowledge of structured programming."
  },
  "4": {
    "id": "fb76bae4-9885-48a6-a2fa-d0864a578067",
    "source_file": "README_s21_decimal.md",
    "section": "Information",
    "content": "The Decimal value type represents decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 to negative 79,228,162,514,264,337,593,543,950,335. The default value of a Decimal is 0. The Decimal value type is appropriate for financial calculations that require large numbers of significant integral and fractional digits and no round-off errors. The Decimal type does not eliminate the need for rounding. Rather, it minimizes errors due to rounding.\n\nWhen the result of the division and multiplication is passed to the Round method, the result suffers no loss of precision.\n\nA decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.\n\nThe binary representation of a Decimal value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction. The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28. Therefore, the binary representation of a Decimal value the form, ((-2^96 to 2^96) / 10^(0 to 28)), where -(2^96-1) is equal to MinValue, and 2^96-1 is equal to MaxValue.\n\nThe scaling factor also can preserve any trailing zeros in a Decimal number. Trailing zeros do not affect the value of a Decimal number in arithmetic or comparison operations."
  },
  "5": {
    "id": "82ef8aa7-47e7-413c-88dd-a08bbf5af120",
    "source_file": "README_s21_decimal.md",
    "section": "Binary representation",
    "content": "The binary representation of a Decimal number consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the integer number and specify what portion of it is a decimal fraction. The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28.\n\nDecimal number can be implemented as a four-element array of 32-bit signed integers (int bits[4];).\n\nbits[0], bits[1], and bits[2] contain the low, middle, and high 32 bits of the 96-bit integer number accordingly.\n\nbits[3] contains the scale factor and sign, and consists of following parts:\n- Bits 0 to 15, the lower word, are unused and must be zero.\n- Bits 16 to 23 must contain an exponent between 0 and 28, which indicates the power of 10 to divide the integer number.\n- Bits 24 to 30 are unused and must be zero.\n- Bit 31 contains the sign; 0 meaning positive, and 1 meaning negative.\n\nNote that the bit representation differentiates between negative and positive zero. These values can be treated as being equal in all operations."
  },
  "6": {
    "id": "3ece58cb-2d72-475b-9493-d58f5811f3b9",
    "source_file": "README_s21_decimal.md",
    "section": "Arithmetic Operators",
    "content": "| Operator name | Operators  | Function                                                                           | \n| ------ | ------ |------------------------------------------------------------------------------------|\n| Addition | + | int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)         |\n| Subtraction | - | int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) |\n| Multiplication |  | int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal result) | \n| Division | / | int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) |\n| Modulo | Mod | int s21_mod(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) |\n\nThe functions return the error code:\n- 0 - OK\n- 1 - the number is too large or equal to infinity\n- 2 - the number is too small or equal to negative infinity\n- 3 - division by 0\n\nNote on the numbers that do not fit into the mantissa:\n- When getting numbers that do not fit into the mantissa during arithmetic operations, use bank rounding (for example, 79,228,162,514,264,337,593,543,950,335 - 0.6 = 79,228,162,514,264,337,593,543,950,334)\n\nNote on the mod operation:\n- If an overflow occurred as a result, discard the fractional part (for example, 70,000,000,000,000,000,000,000,000,000 % 0.001 = 0.000)"
  },
  "7": {
    "id": "47ce1395-6af4-46da-ad7d-b562520da516",
    "source_file": "README_s21_decimal.md",
    "section": "Comparison Operators",
    "content": "| Operator name | Operators  | Function | \n| ------ | ------ | ------ |\n| Less than |  |  int s21_is_greater(s21_decimal, s21_decimal) |\n| Greater than or equal to | >= | int s21_is_greater_or_equal(s21_decimal, s21_decimal) | \n| Equal to | == |  int s21_is_equal(s21_decimal, s21_decimal) |\n| Not equal to | != |  int s21_is_not_equal(s21_decimal, s21_decimal) |\n\nReturn value:\n- 0 - FALSE\n- 1 - TRUE"
  },
  "8": {
    "id": "a00388ea-216a-4e24-9456-e2308fd4518e",
    "source_file": "README_s21_decimal.md",
    "section": "Convertors and parsers",
    "content": "| Convertor/parser | Function | \n| ------ | ------ |\n| From int  | int s21_from_int_to_decimal(int src, s21_decimal *dst) |\n| From float  | int s21_from_float_to_decimal(float src, s21_decimal *dst) |\n| To int  | int s21_from_decimal_to_int(s21_decimal src, int *dst) |\n| To float  | int s21_from_decimal_to_float(s21_decimal src, float *dst) |\n\nReturn value - code error:\n- 0 - OK\n- 1 - convertation error\n\nNote on the conversion of a float type number:\n- If the numbers are too small (0  79,228,162,514,264,337,593,543,950,335) or are equal to infinity, return an error\n- When processing a number with the float type, convert all the significant decimal digits contained in it. If there are more than 7 such digits, the number is rounded to the closest one that does not have more than 7 significant decimal digits.\n\nNote on the conversion from decimal type to int:\n- If there is a fractional part in a decimal number, it should be discarded (for example, 0.9 is converted to 0)"
  },
  "9": {
    "id": "f9e17637-6e82-468e-b1dd-ca574e8a83b7",
    "source_file": "README_s21_decimal.md",
    "section": "Another functions",
    "content": "| Description | Function                                                         | \n| ------ |------------------------------------------------------------------|\n| Rounds a specified Decimal number to the closest integer toward negative infinity. | int s21_floor(s21_decimal value, s21_decimal *result)            |\t\n| Rounds a decimal value to the nearest integer. | int s21_round(s21_decimal value, s21_decimal *result)    |\n| Returns the integral digits of the specified Decimal; any fractional digits are discarded, including trailing zeroes. | int s21_truncate(s21_decimal value, s21_decimal *result) |\n| Returns the result of multiplying the specified Decimal value by negative one. | int s21_negate(s21_decimal value, s21_decimal *result)   |\n\nReturn value - code error:\n- 0 - OK\n- 1 - calculation error"
  },
  "10": {
    "id": "485fb257-debf-4a50-bd6c-fbe3cbabdc03",
    "source_file": "README_s21_decimal.md",
    "section": "Part 1. Implementation of the decimal.h library functions",
    "content": "The functions of the decimal.h library described above must be implemented:\n- The library must be developed in C language of C11 standard using gcc compiler\n- The library code must be located in the src folder on the develop branch   \n- Do not use outdated and legacy language constructions and library functions. Pay attention to the legacy and obsolete marks in the official documentation on the language and the libraries used. Use the POSIX.1-2017 standard.\n- When writing code it is necessary to follow the Google style\n- Make it as a static library (with the s21_decimal.h header file)\n- The library must be developed according to the principles of structured programming;\n- Use prefix s21_ before each function\n- Prepare full coverage of library functions code with unit-tests using the Check library\n- Unit tests must cover at least 80% of each function (checked using gcov)   \n- Provide a Makefile for building the library and tests (with targets all, clean, test, s21_decimal.a, gcov_report)  \n- The gcov_report target should generate a gcov report in the form of an html page. Unit tests must be run with gcov flags to do this\n- When implementing decimal, stick to the binary representation with the integer bits array as specified in the example above. Observe the position of the digits of a number in the bits array\n- It is forbidden to use the __int128 type\n- Trailing zeros can be as preserved as deleted (except for the s21_truncate function)\n- The defined type must support numbers from -79,228,162,514,264,337,593,543,950,335 to +79,228,162,514,264,337,593,543,950,335."
  },
  "11": {
    "id": "e87b0815-ca88-4c8a-93e9-5a348984132a",
    "source_file": "README_s21_string_plus.md",
    "section": "s21_string+",
    "content": "Implementation of the string.h library with additions.\n\nThe russian version of the task can be found in the repository."
  },
  "12": {
    "id": "29a0f9b2-4305-47d5-bbea-e0e90f7d6ffa",
    "source_file": "README_s21_string_plus.md",
    "section": "Contents",
    "content": "0. Preamble\n1. Chapter I \\\n    1.1. Introduction\n2. Chapter II \\\n    2.1. Information\n3. Chapter III \\\n    3.1. Part 1  \n    3.2. Part 2  \n    3.3. Part 3  \n    3.4. Part 4  \n    3.5. Part 5"
  },
  "13": {
    "id": "863673dc-5d57-4a8d-81a5-ad6bb62eda3d",
    "source_file": "README_s21_string_plus.md",
    "section": "Preamble",
    "content": "!s21_string+\n\n1942, late evening, Bletchley Park, Alan Turing's desk. For almost a year, a group of smartest mathematicians, linguists, and crossword puzzle enthusiasts has been trying to solve the most difficult problem of deciphering the German Enigma encryption machine, the codes for which change every day, and the number of possible combinations is about two to the power of 64. The group often had to come up with different algorithms, and they even developed a special set of keywords and their syntax for the convenience of communication and logging and it’s exactly like the well-known C language in our universe. What a remarkable coincidence! But there was one difficulty – the Bletchley Park workers had to keep the entire sequence of actions described in this language in their heads. \n\nAs you walk past Turing's desk, you notice a sheet that says \"For letters, punctuation marks, words, and sentences processing\".\n\n- \"What is this, Alan?\" you said to the thoughtful young man standing at the window.\n\n-- \"These are the functions that will make our lives easier! You know, deciphering Enigma by brute force…I'd rather marry Joan than we do that. Therefore, it seems that we need to keep analysing texts, looking for patterns and coincidences. And so, we’ll have to come up with various algorithms related to the processing of that very text and describe them. That is why we need a number of functions to help us with that. I'm working on them now.\"\n\n- \"And you do that using our new unified algorithms representing tool?\"\n\n-- \"Yes, this is exactly how I do it. Where else could we use these functions?\" having said that, Turing looked at you as if you were a narrow minded person. You realised it and decided to show off your knowledge of the question:\n\n- \"You know I think we really need this. I just recently learned this \"specific language of algorithms transmission\".\"\n\n-- \"Seriously?\" Alan asked with some interest.\n\n- \"Well, yes.\"\n\nAfter a few seconds, Turing came to a logical conclusion to entrust the job to you:\n\n*-- \"Listen, do you want to do it yourself? Get some not-so-busy \npeople and go ahead. And I'll keep working on my mechanical code-breaking machine.\"*\n\nAfter thinking about it for a few seconds, you decide it's a great idea:\n\n- \"Yes, we’ll do everything in a best possible way!\""
  },
  "14": {
    "id": "79018df1-68be-47f6-a96b-ed20f138c8b8",
    "source_file": "README_s21_string_plus.md",
    "section": "Introduction",
    "content": "In this project you will develop your own implementation of the string.h library in C programming language with some additions (with your own implementation of sprintf and sscanf functions). The string.h library is the main C library for string processing. As part of the project you’ll work on tasks with string data and consolidate the structured approach."
  },
  "15": {
    "id": "c4cbd9a2-768d-4c01-a4a6-8af92790cfde",
    "source_file": "README_s21_string_plus.md",
    "section": "Information",
    "content": "The C programming language has a set of functions implementing operations on strings (character strings and byte strings) in its standard library. Various operations, such as copying, concatenation, tokenization and searching are supported. For character strings, the standard library uses the convention that strings are null-terminated: a string of n characters is represented as an array of n + 1 elements, the last of which is a \"NULL\" character. \\\nThe only support for strings in the programming language proper is that the compiler translates quoted string constants into null-terminated strings."
  },
  "16": {
    "id": "703403dc-ba84-4463-91cb-89e6fc1c2619",
    "source_file": "README_s21_string_plus.md",
    "section": "string.h Types",
    "content": "| No. | Variable | Description |\n| ------ | ------ | ------ |\n| 1 | size_t | This is the unsigned integral type and is the result of the sizeof keyword. |"
  },
  "17": {
    "id": "87fd6f6d-a13e-4820-94cc-0f5f3586465b",
    "source_file": "README_s21_string_plus.md",
    "section": "string.h Macro",
    "content": "| No. | Macro | Description |\n| ------ | ------ | ------ |\n| 1 | NULL | This macro is the value of a null pointer constant. |"
  },
  "18": {
    "id": "bc5f706e-7fa8-4ca1-95bf-3b00184325c0",
    "source_file": "README_s21_string_plus.md",
    "section": "string.h Functions",
    "content": "| No. | Function | Description |\n| ------ | ------ | ------ |\n| 1 | void memchr(const void str, int c, size_t n) | Searches for the first occurrence of the character c (an unsigned char) in the first n bytes of the string pointed to, by the argument str. |\n| 2 | int memcmp(const void str1, const void str2, size_t n) | Compares the first n bytes of str1 and str2. |\n| 3 | void memcpy(void dest, const void *src, size_t n) | Copies n characters from src to dest. |\n| 4 | void memset(void str, int c, size_t n) | Copies the character c (an unsigned char) to the first n characters of the string pointed to, by the argument str. |\n| 5 | char strncat(char dest, const char *src, size_t n) | Appends the string pointed to, by src to the end of the string pointed to, by dest up to n characters long. |\n| 6\t| char strchr(const char str, int c) | Searches for the first occurrence of the character c (an unsigned char) in the string pointed to, by the argument str. |\n| 7 | int strncmp(const char str1, const char str2, size_t n) | Compares at most the first n bytes of str1 and str2. |\n| 8 | char strncpy(char dest, const char *src, size_t n) | Copies up to n characters from the string pointed to, by src to dest. |\n| 9 | size_t strcspn(const char str1, const char str2) | Calculates the length of the initial segment of str1 which consists entirely of characters not in str2. |\n| 10 | char *strerror(int errnum) | Searches an internal array for the error number errnum and returns a pointer to an error message string. You need to declare macros containing arrays of error messages for mac and linux operating systems. Error descriptions are available in the original library. Checking the current OS is carried out using directives. |\n| 11 | size_t strlen(const char *str) | Computes the length of the string str up to but not including the terminating null character. |\n| 12 | char strpbrk(const char str1, const char *str2) | Finds the first character in the string str1 that matches any character specified in str2. |\n| 13 | char strrchr(const char str, int c) | Searches for the last occurrence of the character c (an unsigned char) in the string pointed to by the argument str. |\n| 14 | char strstr(const char haystack, const char *needle) | Finds the first occurrence of the entire string needle (not including the terminating null character) which appears in the string haystack. |\n| 15 | char strtok(char str, const char *delim) | Breaks string str into a series of tokens separated by delim. |"
  },
  "19": {
    "id": "15f35aa4-e40e-4f5b-adcd-5346bf71a569",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf and sscanf",
    "content": "- int sscanf(const char str, const char format, ...) - reads formatted input from a string.\n- int sprintf(char str, const char format, ...) - sends formatted output to a string pointed to, by str.\n\nwhere:\n- str − This is the C string that the function processes as its source to retrieve the data;\n- format − This is the C string that contains one or more of the following items: Whitespace character, Non-whitespace character and Format specifiers. A format specifier for print functions follows this prototype: %[flags][width][.precision][length]specifier. A format specifier for scan functions follows this prototype: %[*][width][length]specifier."
  },
  "20": {
    "id": "deac1c50-e9a2-4637-9bda-715921e5edc4",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf And sscanf Specifiers",
    "content": "| No. | Specifier | sprintf output | sscanf output |\n| --- | --- | --- | --- |\n| 1 | c | Character | Character |\n| 2 | d | Signed decimal integer | Signed decimal integer |\n| 3 | i | Signed decimal integer | Signed integer (may be decimal, octal or hexadecimal) |\n| 4 | e | Scientific notation (mantissa/exponent) using e character (the output of the numbers must match up to e-6) | Decimal floating point or scientific notation (mantissa/exponent) |\n| 5 | E | Scientific notation (mantissa/exponent) using E character | Decimal floating point or scientific notation (mantissa/exponent) |\n| 6 | f | Decimal floating point | Decimal floating point or scientific notation (mantissa/exponent) |\n| 7 | g | Uses the shortest representation of decimal floating point | Decimal floating point or scientific notation (mantissa/exponent) |\n| 8 | G | Uses the shortest representation of decimal floating point | Decimal floating point or scientific notation (mantissa/exponent) |\n| 9 | o | Unsigned octal | Unsigned octal |\n| 10 | s | String of characters | String of characters |\n| 11 | u | Unsigned decimal integer | Unsigned decimal integer |\n| 12 | x | Unsigned hexadecimal integer | Unsigned hexadecimal integer (any letters) |\n| 13 | X | Unsigned hexadecimal integer (capital letters) | Unsigned hexadecimal integer (any letters) |\n| 14 | p | Pointer address | Pointer address |\n| 15 | n | Number of characters printed until %n occurs | Number of characters scanned until %n occurs |\n| 16 | % | Character % | Character % |"
  },
  "21": {
    "id": "57cadd94-d6bf-4e8b-9127-4f44ba16a941",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf Flags",
    "content": "| No. | Flags | Description |\n| --- | --- | --- |\n| 1 | - | Left-justify within the given field width; Right justification is the default (see width sub-specifier). |\n| 2 | + | Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a -ve sign. |\n| 3 | (space) | If no sign is going to be written, a blank space is inserted before the value. |\n| 4 | # | Used with o, x or X specifiers the value is preceded with 0, 0x or 0X respectively for values different than zero. Used with e, E and f, it forces the written output to contain a decimal point even if no digits would follow. By default, if no digits follow, no decimal point is written. Used with g or G the result is the same as with e or E but trailing zeros are not removed. |\n| 5 | 0 | Left-pads the number with zeroes (0) instead of spaces, where padding is specified (see width sub-specifier). |"
  },
  "22": {
    "id": "acba9c08-6654-40c2-8094-798e84df4c9c",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf And sscanf Width Description",
    "content": "| No. |\tWidth | Description |\n| --- | --- | --- |\n| 1\t| (number) | Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. |\n| 2 |  | In sprintf the  sign means, that the width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. In sscanf the * sign placed after % and before the format specifier reads data of the specified type, but suppresses their assignment. |"
  },
  "23": {
    "id": "6c59b43a-0547-4fc9-a466-11081b2a5d67",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf Precision Description",
    "content": "| No. |\t.precision | Description |\n| --- | --- | --- |\n| 1\t| .number | For integer specifiers (d, i, o, u, x, X) − precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0. For e, E and f specifiers − this is the number of digits to be printed after the decimal point. For g and G specifiers − This is the maximum number of significant digits to be printed. For s − this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. For c type − it has no effect. When no precision is specified for specifiers e, E, f, g and G, the default one is 6. When no precision is specified for all other kind of specifiers, the default is 1. If the period is specified without an explicit value for precision, 0 is assumed. |\n| 2\t| .* | The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. |"
  },
  "24": {
    "id": "be8d0aa0-55ec-401a-a625-a24e1846f319",
    "source_file": "README_s21_string_plus.md",
    "section": "sprintf And sscanf Length Description",
    "content": "| No. |\tLength | Description |\n| --- | --- | --- |\n| 1 | h | The argument is interpreted as a short int or unsigned short int (only applies to integer specifiers: i, d, o, u, x and X). |\n| 2 | l | The argument is interpreted as a long int or unsigned long int for integer specifiers (i, d, o, u, x and X), and as a wide character or wide character string for specifiers c and s. |\n| 3 | L | The argument is interpreted as a long double (only applies to floating point specifiers − e, E, f, g and G). |"
  },
  "25": {
    "id": "a32caccb-6f29-43f0-a70c-bb7cb4d4fa8e",
    "source_file": "README_s21_string_plus.md",
    "section": "Special string processing functions (from the String class in C#)",
    "content": "| No. | Function | Description |\n| ------ | ------ | ------ |\n| 1 | void to_upper(const char str) | Returns a copy of string (str) converted to uppercase. In case of any error, return NULL |\n| 2 | void to_lower(const char str) | Returns a copy of string (str) converted to lowercase. In case of any error, return NULL |\n| 3 | void insert(const char src, const char *str, size_t start_index) | Returns a new string in which a specified string (str) is inserted at a specified index position (start_index) in the given string (src). In case of any error, return NULL |\n| 4 | void trim(const char src, const char *trim_chars) | Returns a new string in which all leading and trailing occurrences of a set of specified characters (trim_chars) from the given string (src) are removed. In case of any error, return NULL |"
  },
  "26": {
    "id": "873de296-5ad7-44c0-a931-4cd92b6fc1d8",
    "source_file": "README_s21_string_plus.md",
    "section": "Part 1. Implementation of the string.h library functions",
    "content": "It is necessary to implement the described above functions of the string.h library: \n - The library must be developed in C language of C11 standard using gcc compiler\n - The library's code, including headers, makefile and library itself must be located in the src folder on the develop branch    \n - Do not use outdated and legacy language constructions and library functions. Pay attention to the legacy and obsolete marks in the official documentation on the language and the libraries used. Use the POSIX.1-2017 standard. \n - When writing code it is necessary to follow the Google style\n - Make it as a static library (with the header file s21_string.h)\n - The library must be developed in accordance with the principles of structured programming, duplication in the code must be avoided\n - Prepare a full coverage of the library's functions by unit-tests using the Check library\n - Test's code and the executable file must be located in the src folder or its any subfolder\n - Unit-tests must check the results of your implementation by comparing them with the implementation of the standard string.h library\n - Unit tests must cover at least 80% of each function (checked using gcov)\n - Provide a Makefile for building the library and tests (with the targets all, clean, test, s21_string.a, gcov_report)\n - The gcov_report target should generate a gcov report in the form of an html page. Unit tests must be run with gcov flags to do this\n - Use prefix s21_ before each function\n - It is forbidden to copy the implementation of the standard string.h library and other string processing libraries and to use them anywhere, except unit-tests\n - It is forbidden to use system errors arrays, including those not specified in POSIX (sys_nerr, sys_errlist). Instead, you need to implement your own platform-specific errors arrays, as it was mentioned in the description of the strerror function  \n - You must follow the logic of the standard string.h library (in terms of checks, working with memory and behavior in emergency situations - tests will help you with that)\n - Functions must work with z-string made of single-byte characters in ASCII encoding."
  },
  "27": {
    "id": "344070d3-a6a0-4081-8f07-97f5a18a81c8",
    "source_file": "README_s21_string_plus.md",
    "section": "Part 2. Partial implementation of the sprintf function",
    "content": "It is necessary to implement the sprintf function from the stdio.h library:\n- The function must be placed in the s21_string.h library\n- All of the requirements outlined in the first part are applied to function implementation.\n- The next partial formatting must be supported:\n  - Specifiers: c, d, f, s, u, %\n  - Flags: -, +, (space)\n  - Width description: (number)\n  - Precision description: .(number)\n  - Length description: h, l"
  },
  "28": {
    "id": "c6a7d960-c788-47ea-a77e-f16cb8ac75b5",
    "source_file": "README_s21_string_plus.md",
    "section": "Part 3. Bonus. Implementation of some format modifiers of the sprintf function",
    "content": "Bonus assignment for extra points. It is necessary to implement some format modifiers of the sprintf function from the stdio.h library:\n- The function must be placed in the s21_string.h library\n- All of the requirements outlined in the first part are applied to function implementation.\n- The next additional format modifiers must be supported:\n  - Specifiers: g, G, e, E, x, X, o, p\n  - Flags: #, 0\n  - Width description: *\n  - Precision description: .*\n  - Length description: L"
  },
  "29": {
    "id": "93951d40-2b6c-46f7-9f94-4e7e05945076",
    "source_file": "README_s21_string_plus.md",
    "section": "Part 4. Bonus. Implementation of the sscanf function",
    "content": "Bonus assignment for extra points. It is necessary to implement the sscanf function from the stdio.h library:\n- The function must be placed in the s21_string.h library\n- All of the requirements outlined in the first part are applied to function implementation.\n- Full formatting (including flags, widths, precision, modifiers and conversion types) must be supported."
  },
  "30": {
    "id": "b7336467-1b0b-40b5-ae7b-66485cc86815",
    "source_file": "README_s21_string_plus.md",
    "section": "Part 5. Bonus. Implementation of special string processing functions",
    "content": "Bonus assignment for extra points. You must implement some string processing functions from the String class (described here):\n- The functions must be placed in the s21_string.h library.\n- All of the requirements outlined in the first part are applied to functions implementation, \n  excluding the requirement to compare your implementation with the standard.\n\n\n💡 Tap here to leave your feedback on the project. Pedago Team really tries to make your educational experience better."
  },
  "31": {
    "id": "3cc29428-1160-41c1-ba3e-ddc34cbec6e4",
    "source_file": "README_simple_bash.md",
    "section": "Simple Bash Utils",
    "content": "Development of Bash text utilities: cat, grep.\n\nThe russian version of the task can be found in the repository."
  },
  "32": {
    "id": "f32db23e-610a-405a-b475-ad4d857b47ea",
    "source_file": "README_simple_bash.md",
    "section": "Contents",
    "content": "0. Preamble\n1. Chapter I \\\n   1.1. Introduction\n2. Chapter II \\\n   2.1. Information\n3. Chapter III \\\n   3.1. Part 1  \n   3.2. Part 2  \n   3.3. Part 3  \n   3.4. Part 4"
  },
  "33": {
    "id": "ce0b058e-d8be-442f-9884-6714ac809ec4",
    "source_file": "README_simple_bash.md",
    "section": "Preamble",
    "content": "!simple_bash_utils\n\nIt was an ordinary grey autumn day in 1993. You came home from work at Hewlett-Packard, feeling a little tired. You had a small two-room apartment on the outskirts of N town. There was a low-alcohol drink in the refrigerator called \"pivo\". You took that drink and a bag of crackers then went to your little nook, to your computer made by Dell.\n\nClick - the power button was pressed. A couple of minutes of boot loading and... yeah, it feels good. You always get that feeling when you turn on a computer. A few seconds of undisturbed pleasure and you opened\nthe Mosaic browser. Then you went to your favorite forum, and while drinking pivo, you read some threads. Suddenly you came across a very interesting discussion, which began with the following message:\n\n> Hello everybody out there using minix -\n>\n>I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. This has been brewing since april, and is starting to get ready. I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat (same physical layout of the file-system (due to practical reasons) among other things).\n>\n>I've currently ported bash(1.08) and gcc(1.40), and things seem to work. This implies that I'll get something practical within a few months, and I'd like to know what features most people would want. Any suggestions are welcome, but I won't promise I'll implement them :-)\n>\n>Linus (torvalds@kruuna.helsinki.fi)\n>\n>PS. Yes - it's free of any minix code, and it has a multi-threaded fs. It is NOT portable (uses 386 task switching etc), and it probably never will support anything other than AT-harddisks, as that's all I have :-(.\n>\n>— Linus Torvalds\n\n\"Very interesting,\" you thought to yourself. As you scrolled down, you noticed that bash is not that well ported, and some functions didn't work. \nIn particular, there were problems with the utilities for word processing: cat and grep.\n\"Interesting task, and it would be great to help this Linus Torvalds,\" you said aloud and immediately wrote a message in the thread saying that you're already working on it. \nWell, let’s start!"
  },
  "34": {
    "id": "f19e4522-270a-452e-b2c7-805055c0c10b",
    "source_file": "README_simple_bash.md",
    "section": "Introduction",
    "content": "In this project you will learn and develop basic Bash utilities for working with C programming language texts. These utilities (cat and grep) are often used in the Linux terminal. As part of the project you’ll learn the organization of the Bash utilities and solidify knowledge of structured programming."
  },
  "35": {
    "id": "3963a744-5aa1-424a-a2eb-88cd063b1267",
    "source_file": "README_simple_bash.md",
    "section": "cat History",
    "content": "> cat was part of the early versions of Unix, e.g., Version 1, and replaced pr, a PDP-7 and Multics utility for copying a single file to the screen."
  },
  "36": {
    "id": "c53f40c6-290a-4c58-a29d-57b8dde13292",
    "source_file": "README_simple_bash.md",
    "section": "cat Usage",
    "content": "Cat is one of the most frequently used commands on Unix-like operating systems. It has three related functions with regard to text files: displaying them, combining copies of them and creating new ones.\n\ncat [OPTION] [FILE]..."
  },
  "37": {
    "id": "517a8cc0-e740-434d-b554-80bff671a750",
    "source_file": "README_simple_bash.md",
    "section": "cat Options",
    "content": "| No. | Options | Description |\n| ------ | ------ | ------ |\n| 1 | -b (GNU: --number-nonblank) | numbers only non-empty lines |\n| 2 | -e implies -v (GNU only: -E the same, but without implying -v) | but also display end-of-line characters as $  |\n| 3 | -n (GNU: --number) | number all output lines |\n| 4 | -s (GNU: --squeeze-blank) | squeeze multiple adjacent blank lines |\n| 5 | -t implies -v (GNU: -T the same, but without implying -v) | but also display tabs as ^I  |"
  },
  "38": {
    "id": "bcc03b69-81e2-4c90-9572-180d416e293a",
    "source_file": "README_simple_bash.md",
    "section": "grep History",
    "content": "> Thompson wrote the first version in PDP-11 assembly language to help Lee E. McMahon analyze the text of the Federalist Papers to determine authorship of the individual papers. The ed text editor (also authored by Thompson) had regular expression support but could not be used on such a large amount of text, so Thompson excerpted that code into a standalone tool. He chose the name because in ed, the command g/re/p would print all lines matching a specified pattern. grep was first included in Version 4 Unix. Stating that it is \"generally cited as the prototypical software tool\", McIlroy credited grep with \"irrevocably ingraining\" Thompson's tools philosophy in Unix."
  },
  "39": {
    "id": "99dd74b6-c2b8-4274-8711-b584f61a6ded",
    "source_file": "README_simple_bash.md",
    "section": "grep Options",
    "content": "| No. | Options | Description |\n| ------ | ------ | ------ |\n| 1 | -e | pattern |\n| 2 | -i | Ignore uppercase vs. lowercase.  |\n| 3 | -v | Invert match. |\n| 4 | -c | Output count of matching lines only. |\n| 5 | -l | Output matching files only.  |\n| 6 | -n | Precede each matching line with a line number. |\n| 7 | -h | Output matching lines without preceding them by file names. |\n| 8 | -s | Suppress error messages about nonexistent or unreadable files. |\n| 9 | -f file | Take regexes from a file. |\n| 10 | -o | Output the matched parts of a matching line. |"
  },
  "40": {
    "id": "60bd18a9-ea8a-40c3-b894-6d7b4c9ebd47",
    "source_file": "README_simple_bash.md",
    "section": "Chapter III",
    "content": "- The programs must be developed in C language of C11 standard using gcc compiler.\n- The program code of the cat and grep must be located on the develop branch in the src/cat/ and src/grep/ folders, respectively  \n- Do not use outdated and legacy language constructions and library functions. Pay attention to the legacy and obsolete marks in the official documentation on the language and the libraries used. Use the POSIX.1-2017 standard.\n- When writing code it is necessary to follow the Google style\n- The programs must be executable files with command line arguments\n- The programs must be built with Makefile with appropriate targets: s21_cat, s21_grep\n- If third-party libraries are used, there must be build scripts in makefile to connect/load them\n- Integration tests must cover all flag variants and input values, based on a comparison with the behavior of real Bash utilities \n- The programs must be developed according to the principles of structured programming\n- Code duplication must be avoided, common modules must be reused between the utilities. Common modules can be moved to a separate folder src/common\n- You can use standard and non-standard C libraries, or you can use your own developed libraries from other projects\n- The statement of the message in the case of an error does not matter\n- Input via stdin is not required to be supported"
  },
  "41": {
    "id": "2dbbc734-96c3-4210-bb03-ea6ef9ea455b",
    "source_file": "README_simple_bash.md",
    "section": "Part 1. Working with the cat utility",
    "content": "You need to develop a cat utility:\n- Support of all flags (including GNU versions) specified above\n- The source, header, and build files must be placed in the src/cat/ directory\n- The resulting executable file must be placed in the directory src/cat/ and named s21_cat"
  },
  "42": {
    "id": "e3cf8134-573a-47f8-a883-4657cbdcf260",
    "source_file": "README_simple_bash.md",
    "section": "Part 2. Working with grep utility",
    "content": "You need to develop the grep utility:\n- Support of the following flags: -e, -i, -v, -c, -l, -n\n- Only pcre or regex libraries can be used for regular expressions\n- The source, header and make files must be placed in the src/grep/ directory\n- The resulting executable file must be placed in the directory src/grep/ and named s21_grep"
  },
  "43": {
    "id": "abc3f976-ef32-4c74-8e1d-a9ca9c57e98b",
    "source_file": "README_simple_bash.md",
    "section": "Part 3. Bonus. Implementation of some grep utility flags",
    "content": "Bonus assignment for extra points. You need to develop the grep utility:\n- Support of all flags, including: -h, -s, -f, -o\n- Only pcre or regex libraries can be used for regular expressions\n- The source, header and make files must be placed in the src/grep/ directory\n- The resulting executable file must be placed in the directory src/grep/ and named s21_grep"
  },
  "44": {
    "id": "ea3f7d5b-77cd-4688-95da-2f8a8d3af81e",
    "source_file": "README_simple_bash.md",
    "section": "Part 4. Bonus. Implementation of grep utility flag combinations",
    "content": "Bonus assignment for extra points. You need to develop the grep utility:\n- Support of all flags, including their _pair_ combinations (e.g. -iv, -in)\n- Only pcre or regex libraries can be used for regular expressions\n- The source, header and make files must be placed in the src/grep/ directory\n- The resulting executable file must be placed in the directory src/grep/ and named s21_grep\n\n\n\n💡 Tap here to leave your feedback on the project. Pedago Team really tries to make your educational experience better."
  },
  "45": {
    "id": "7db18205-704d-4325-b580-05bd339e728e",
    "source_file": "about.txt",
    "section": "text file",
    "content": "Бесплатная школа программирования и цифровых технологий от Сбера\nСамый быстрый способ попасть в ИТ — оказаться в кругу единомышленников. Освой новую профессию, познакомься с будущими коллегами и получи опыт реальной разработки уже во время обучения.\nПоступить\nБлижайший набор\nСписок городов\nОбучение от 6 мес. до 2 лет\nСрок обучения будет зависеть от выбранной профессии. Обучение на профессии разработчика займёт от 1,5 до 2 лет, по специальностям DevOps, SRE-инженер, Data Scientist, тестировщик (QA-инженер), бизнес-аналитик (BA) и системный аналитик (SA) от 6 до 12 месяцев.\nСтажировка в ИТ-компании\nПоработай над реальными задачами и получи фидбек от лидеров в ИТ. На платформе «Школы 21» реализован карьерный трек, который помогает подготовиться к стажировке.\nПодход «равный равному»\nВыполняй задания, проверяй проекты других участников и обменивайся знаниями. Обучайся без лекций и расписаний.\nСовременный кампус\nКампусы «Школы 21» открыты 24/7 и 365 дней в году. В них есть всё для эффективного обучения: рабочие места, компьютеры и игровые комнаты, чтобы отдохнуть.\nПомогаем раскрыть потенциал и готовим к успешной карьере в ИТ\nВ «Школе 21» участники одновременно развивают жёсткие и мягкие навыки: в группах и самостоятельно выполняют проекты из практики крупных ИТ-компаний, проводят взаимные проверки и код-ревью, учатся давать и принимать обратную связь.\nПодробнее о трудоустройстве\n8 400\nАктивных участников обучения\n100%\nУспешно трудоустроено\nПрограмма обучения\nВсе участники обязательно изучают базу программирования в рамках выбранного направления\n\n \n\nРазработчик ПО\nDevOps- и SRE-инженеры\nQA-инженер\nData Scientist\nСпециалист по кибербезопасности\nБизнес- и системный аналитик\n\n\nМашинное обучение\nНаучимся решать задачи классификации, регрессии и кластеризации, работать с очисткой и предобработкой данных, применять регуляризацию и создавать ансамбли моделей\nNLP\nОвладеем ключевыми инструментами обработки текстовых данных: токенизацией, стеммингом, лемматизацией, работой со стоп-словами, моделями bag of words, word2vec и алгоритмом TF-IDF\nРекомендательные системы\nРазработаем различные типы рекомендательных систем: неперсонализированные, основанные на контенте и с коллаборативной фильтрацией. Изучим метрики оценки их качества\nНейронные сети\nПоймём устройство полносвязных нейронных сетей (FCN), разберём принципы работы скрытых нейронов, обратного распространения ошибки (back-propagation) и активационных функций\nВременные ряды\nНаучимся прогнозировать временные ряды, такие как спрос на такси в разных локациях города. Изучим методы работы с временными данными: средние, скользящие средние, экспоненциальное сглаживание, SARIMA и использование глубокого обучения\nКомпьютерное зрение\nИзучим разметку данных, детекцию объектов, предобработку изображений, работу с масками, аугментацию данных, а также освоим CNN и Transfer Learning\nИ проходят подготовку к работе в ИТ‑компании\n\nКарьерный трек\nКарьерный трек — это набор проектов которые готовят к успешному трудоустройству. В процессе подготовки к стажировке и корпоративной работе участники тренируются составлять резюме и проходить собеседования\nСтажировка\nСтажировка — обязательный учебный проект. Участники сами ищут ИТ-компанию для практики на 3 месяца, но если будут трудности, школа поможет. Именно в это время большинство получает первое предложение о работе\nПосле стажировки каждый участник может изучить глубже слудующие направления\nБольшие данные\nГеоданные\nАнализ графов\nВ «Школу 21» может\nпоступить любой желающий\nНеважно, что ты знаешь об ИТ и какое у тебя образование. Главное — твоё желание и мотивация. Мы даём шанс всем попробовать свои силы и освоить новое направление.\nГибкий график\nКампусы «Школы 21» открыты 24/7/365, а на обучение нужно минимум 20 часов в неделю\nБез дипломов и ЕГЭ\nДля поступления достаточно пройти вступительные испытания\nБез знаний в ИТ\nОбучение подходит для участников с нулевым опытом\nОбучение с 18 лет без верхней планки\nСамому старшему участнику 63 года\nПодробнее о поступлении\nimg\n50%\nучастников пришли в школу без опыта программирования\nЭтапы поступления\nВступительное испытание — игра, пройди и попадёшь на отборочный интенсив\n\nПоступить\n1 этап\n≈ 60 мин\nИгра\nПройди ИГРУ на память и логику. Понять правила — тоже часть задания. Заработай нужное количество баллов и получи приглашение на следующий этап.\n\nОнлайн\n2 этап\n≈ 20 мин\nВидео о школе\nПосмотри видео о школе в личном кабинете. В видео мы расскажем всё об обучении, развеем сомнения и дадим подробную информацию о том, что тебя ждёт в школе.\n\nОнлайн\n3 этап\n≈ 26 дней\nОтборочный «бассейн»\nЗа 26 дней интенсива ты окунёшься в мир программирования и поймёшь, насколько тебе подходит профессия разработчика. Это сложный этап, который требует много усилий. Чтобы его пройти, советуем взять паузу от учёбы, работы и других дел.\n\nОфлайн в кампусе школы\nНачало обучения\nЧерез несколько недель после «бассейна» начнётся учёба\n\n18 мес\nминимальный срок прохождения программы профессии разработчика\n6 мес\nминимальный срок прохождения программ других направлений\nimg\nНет наставников и лекций\nУчись в своём темпе: выполняй задания на платформе школы, смотри вводные ролики и обменивайся знаниями с другими участниками.\nimg\nЗадачи из реальной практики\nПроекты участников максимально приближены к реальным задачам программистов в крупных ИТ- компаниях. Осилишь все, пройдёшь стажировку и станешь сильным разработчиком уровня мидл.\nimg\n«Равный равному»\nВ «Школе 21» участники учатся в своём темпе и помогают друг другу: проверяют проекты, обсуждают задачи и делятся обратной связью.\nimg\nГеймификация\nОбучение похоже на прохождение компьютерной игры. С каждым проектом ты повышаешь уровень, приобретаешь опыт и внутреннюю валюту. Её можно потратить на мерч школы.\nПоступить\nПодробнее об обучении\n\n\nСтажировка\nОбязательная стажировка — 3 месяца\nДля «Школы 21» практика в IT-компании — такой же учебный проект, как и все остальные. Это значит, что ты точно найдёшь стажировку и проявишь себя на реальных проектах. Ты можешь пойти на стажировку в любой момент обучения, когда почувствуешь готовность и уверенность в себе.\n\nПриготовься к интенсивной практике: стажировка — это работа минимум 20 часов в неделю.\n100%\nстажёров получают предложение о работе\nУчастники и выпускники о «Школе 21»\nОтзывы участников «Школы 21»\n\n\nНаталья\nвыпускница\n\nСтарший инженер по разработке, разработчик в тестировании в Сбере\n\nАнна\nучастница\n\nСтудент 2 курса Финансового университета при Правительстве РФ\n\nИрина\nвыпускница\n\nРазработчик BIOS в компании «Аквариус» \n\nАнтон\nвыпускник\n\nDevOps-инженер\n\nВадим\nвыпускник\n\nГлавный инженер по разработке в ПАО Сбербанк\n\nМетодология\nПрокачиваем не только профессиональные, но и мягкие навыки, которые ценятся на рынке в ИТ\niconРабота в команде\niconПрезентация проектов\niconСамостоятельность и дисциплина\niconScrum-мышление\niconБыстрое принятие решений\niconУправление ресурсами\nПодробнее о методике\nimg\nКампусы\nКампусы похожи на офисы ИТ-компаний: современный софт, игровые и всё необходимое для эффективного обучения\nМосква\nМосква\nул. Вятская, д. 27, стр. 42\n\nКазань\nКазань\nул. Спартаковская, д. 2, корп. 2\n\nНовосибирск\nНовосибирск\nпл. Карла Маркса, д. 7\n\nСургут\nСургут\nул. Иосифа Каролинского, д. 14/1\n\nВеликий Новгород\nВеликий Новгород\nул. Великая, д. 18А\n\nЯкутск\nЯкутск\nул. Ойунского, д. 35\n\nЯрославль\nЯрославль\nул. Победы, д. 14А\n\nЛипецк\nЛипецк\nул. Зегеля, д. 1\n\nЮжно-Сахалинск\nЮжно-Сахалинск\nул. Леонова д. 38 (Новый Бизнес-центр)\n\nМагас\nМагас\nул. Никиты Хрущева, д. 10\n\nЧелябинск\nЧелябинск\nпр. Ленина, д. 76а\n\nМагадан\nМагадан\nУл. Кольцевая 3/8\n\nБелгород\nБелгород\nпр. Ватутина, д. 1Г\n\nАнадырь\nАнадырь\nул. Студенческая д.3\n\nНижний Новгород\nНижний Новгород\nул. Тургенева, д. 30\n\nУфа\nУфа\nул. Заки Валиди, д. 32/2б"
  },
  "46": {
    "id": "2d4fb882-b8a7-4882-84e6-740e941a50f1",
    "source_file": "faq.txt",
    "section": "text file",
    "content": "Данный FAQ содержит ответы на популярные вопросы и пополняется в режиме реального времени.\n\nДвижение по графу\na) Какие этапы мне нужно пройти, чтобы выпуститься?\n\nНабрать 11-12 (в зависимости от волны) уровень за счет проектов на вариативных ветках;\nСтартовать (завалидировать) 3-х месячную стажировку.\nЗавершить Career Track. Project 08 (для волн 23_12 и позднее)\nПроекты \"Базы\" - набор обязательных проектов до Career track\nЗависимости и условия открытия проектов участник может посмотреть в карточке интересующего проекта.\nВариативные ветки - наборы проектов после \"Базы\". Открываются в зависимости от связанных проектов в \"Базе\". Могут для открытия требовать сдачу экзамена.\nОбновленные проекты\nПроекты C7, CPP3 и AP2 были заменены на новую серию проектов с использованием легаси - BrickGame.\nПроекты представляют из себя последовательную модернизацию игры BrickGame от проекта к проекту. Для прохождения необходимо использовать собственный легаси код из предыдущей версии проекта.\n\n\nb) Если я ранее выполнил проект C7, а теперь в графе появилась новая версия, должен ли я его пересдавать или он перезачтется? Обязательно ли выполнять новые проекты?\nСтарые и новые проекты, которые пришли им на замену взаимозаменяемые. Настройки следующих за ними проектов установлены таким образом, что нет разницы был выполнен старый проект под этим кодом, или новый.\nНапример, и старый проект СPP3 и новый проект СPP3 BrickGame v2.0 открывают доступ к CPP4. И старая версия экзамена DevOps, и новая версия экзамена DO_Ex равнозначны при открытии доступа к Career track. Поэтому нет необходимости сдавать новую версию проекта, если была успешно сдана старая.\nДойдя до проекта, для которого мы подготовили обновленную замену, у вас есть выбор- сделать старую версию проекта (например, калькулятор - СРР3) или новую версию (BrickGame v2 -СРР3). Если вы взялись выполнять одну из версий проекта, то взять другую в работу вы уже не сможете. \nПри этом дойдя до следующего подобного проекта, например APP2, у вас вновь будет возможность выбрать выполнить старую версию проекта или новый BrickGame v3.0. \n(Тут следует обратить внимание, что проект APP2 доступен на том языке, на котором вы успешно завершили APP1 Bootcamp).\nТаким образом вы можете продолжить выполнять старые версии проектов, если они вам доступны. (Для волн 23_10 и 23_12 старые проекты преимущественно не доступны).\n\n\nc) Я уже выполнил С7 (СРР3/АР2) и ветка в графе светилась зеленым, как выполненная. А теперь вместо старого С7 появился новый проект и ветка перестала светиться зеленым. Нужно ли мне выполнять новый проект, чтобы эта ветка была зачтена, если был выполнен старый проект? Нет, не нужно.\nНа визуальный граф добавлены новые проекты BrickGame и Алгоритмы А1 и А2 на 9 языках. Старые проекты мы исключили из визуального графа, но вы до сих пор можете найти их в разделе Projects.\nЕсли вы выполнили какие-либо из старых проектов, то блоки/ветки соответствующего языка могут не подсвечиваться в визуальном графе зеленым, поскольку старые проекты исключены из визуального графа. Однако это НЕ означает, что вы НЕ завершили работу над этой веткой. И старые и обновленные проекты входят в базу.\nНе обязательно выполнять новые проекты, которые указаны в визуальном графе, если вы выполнили старую версию проекта с таким же кодом (исключение волны 23_10 и 23_12, которым доступны только новые проекты).\n\n\nd) Я уже выполняю калькулятор. Смогу ли я его пересдать, если зафейлю при сдаче? Классам, стартовавшим основное обучение после второй половины 2023 г. (волны 23_10 , 23_12 и позже) мы рекомендуем сосредоточиться на выполнении новых проектов BrickGame. Выполнение калькулятора для вас закрыто. Если вы уже выполняете проект калькулятора, и проект был зафейлен, то у вас не будет возможности пересдать этот проект.\nКлассам, стартовавшим основное обучение до второй половины 2023 г. доступен выбор: старые проекты калькулятора или новые BrickGame. Если участники этих классов находятся в процессе выполнения калькулятора и зафейлят его сдачу, у них будет возможность ретрая. Однако, следует обратить внимание на то, что только один проект с одинаковым кодом доступен для выбора: либо старый калькулятор, либо новый BrickGame. Фактом выбора считается регистрация на проект. Хорошо подумайте перед регистрацией на проект. Изменить выбор можно только в случае гивапа проекта с последующим ретраем, в этом случае проект перейдет в статус без регистрации, и у вас появится возможность регистрации на другой проект.\n\n\ne) Как выполнять BrickGame, если я не выполнял его предыдущие версии? Здесь вам предстоит поработать с легаси кодом. Поскольку вы могли столкнуться с этим проектом уже завершив ветку си, мы допускаем, что легаси может быть не только собственным, но и чужим. Это обычная практика на производстве работать с чужим легаси кодом. Но для успешной сдачи проекта в чужом легаси необходимо разобраться, чтобы не получить чит от проверяющего. Сравнение проектов калькуляторов и обновленных проектов BrickGame\nОсновная цель одинаковая - создать прикладное приложение на разных языках программирования, а также отработать в рамках прикладного приложения работу с интерфейсом и алгоритмическую задачу.\nВторая задача - поработать со своим легаси кодом, развивать свое решение.\nТаким образом мы подсвечиваем важность проектировать свою систему так, чтобы ее было удобно развивать в будущем. Также в проекте брикгейма нужно научиться соединять разные технологи (как в реальных проектах). Еще один важный момент- в этих задачах нет БД, есть работа только с кодом, с логикой и с интерфейсом.\n\n\nКакие проблемы были в калькуляторах, которые решили в брикгеймах:\n\nБыло много десктопных интерфейсов. Это немного устаревший подход, так как они достаточно редко сейчас применяются. В брикгеймах он решен тем, что в каждом проекте свой интерфейс: в первом- терминальный, на С++ - десктопный, далее - веб интерфейс в 3 и 4 брикгейме.\nВ калькуляторах было плохо прописано развитие легаси. В брикгеймах этому уделено отдельное внимание, и прописано что и как нужно делать. В частности был негативный опыт у участников заключавшийся в том, что приходилось переписывать одно и то же. В брикгеймах это свели к минимуму. Игры на всех 4х брикгеймах разные, интерфейсы везде разные, но единый движок, единый подход, единая архитектура. Старые модули модифицировать и переписывать не нужно будет, их нужно будет только подключать.\nПо итогу выполнения всех 4х проектов брикгейма можно получить хороший опыт по интеграции разных решений.\nМультиязычные проекты Алгоритмов\nЗадания алгоритмов представлены на 9 языках программирования: C, C++, Java, Python, Go, C#, Kotlin, Swift, JavaScipt в виде отдельных проектов.\n\nДоступ к проектам А1 на языках Java, Python, Go, C#, Kotlin, Swift, JavaScipt можно получить после успешного завершения интенсива AP1 на соответствующем языке. (Например, AP1 на языке JS откроет доступ только к A1_Maze_JavaScript.\nA1 на языке Си открывается после С7 (новый проект BrickGame v1.0 или старый проект Калькулятор).\nA1 на языке С++ открывается после CPP4 (3DViewer_v2.0)\nПроект A2 открывает доступ к выполнению экзамена по алгоритмам - группа проектов A_Ex.\n\nf) Как мне понять какие проекты нужно выполнять?\nУсловием выхода к вариативным веткам является успешное выполнение проекта Career track. Детальную информацию, какие проекты блокируют Career track вы найдете в карточке проекта.\nВ общих чертах: классам до 23_04 включительно, нужно сдать последний проект на каждой ветке Базы для получения доступа к Career track. \nДля классов 23_10 и 23_12 и позднее, нужно успешно сдать миниэкзамены, чтобы получить доступ к Career track. Обращаясь к карточке каждого проекта можно понять какие проекты блокируют доступ к этому проекту.\n\n\n\nЯзыковые интенсивы\nВ данный момент используются старые версии интенсивов.\nВ них отключены периоды, т.е. регистрироваться и начинать проходить можно в любое время. Сами проекты также не содержат ограничений по времени выполнения.\nДля успешного завершения интенсива нужно успешно завершить половину проектов, т.е. выполнить интенсив на 50%\n\ng) Когда появятся обновленные интенсивы AP1 они перезачтутся или нужно будет обязательно выполнять новые?\nЕсли вы ранее успешно прошли интенсив, то проходить новый (по данному языку) не нужно.\n\n\nh) Когда откроются новые интенсивы? Стоит ли мне сейчас стартовать старые интенсивы?\nМы еще продолжаем работу над тотальной переработкой интенсивов, поэтому пока задерживаемся с их релизом. Мы заблаговременно предупредим о релизе новых интенсивов, их внедрение сделаем максимально мягких и безболезненным. Вам не придется бросать прохождение интенсива, если вы его уже начали.\n\n\ni) Как получить доступ к вариативной ветке?\nДоступ к вариативным веткам происходит после прохождения проекта Career track - Project 08 + буткемп (если указано в условиях этой ветки). Дополнительно проходить мини-экзамены не требуется, если они не являются входным требованием для 8-го проекта карьерного трека. Таким образом, старым волнам (до 23_10) их проходить не нужно.\nПри этом для доступа к каналу стажировок действуют общие правила, и в этом случае потребуется прохождение мини-экзамена по прикладному языку или прохождение мини-экзамена по SQL и DevOps. О правилах попадания в канал описано ниже.\n\n\n\nЭкзамены\nЧтобы систематизировать контроль знаний с помощью экзаменов, в образовательном графе предусмотрены экзамены по каждой ветке Базы.\nВсего необходимо сдать 6 групп экзаменов: DevOps, C, C++, SQL, Алгоритмы, Прикладное программирование (на выбранном языке).\n\n\ng) Я из класса Х, нужно ли мне сдавать экзамены? Условия доступа к каждому проекту вы можете посмотреть в карточке проекта.\nОбщие условия таковы:\n\nВолнам, стартовавшим после середины 2023 года (23_10 и 23_12), нужно сдать миниэкзамены, чтобы получить доступ к Career track, который открывает путь к вариативным веткам. В комментариях мы словили неточность, возвращаемся к первоначальной информации: если участники волн 23_10 и 23_12 успели сдать проект С7 калькулятор, то нет необходимости сдавать C_Ex для получения доступа к Career track.\nВолнам, стартовавшим до середины 2023 года (23_05, 23_04 и ранее), Career track откроется после успешного выполнения последнего проекта на ветке (старой или новой версии проекта). Этим волнам в обязательном порядке сдавать новые миниэкзамены не нужно. Для доступа к вариативным веткам необходимо сдать 8-й проект карьерного трека + соответствующий ветке буткэмп (если указано в условиях).\n\nk) Что если я ранее успешно решил модульный проект экзамена по С++ или DevOps, это зачтется?\nДа, настройки установлены таким образом, что учитывают сдачу старых версий экзаменов по направлению.\n\n\n\nCareer track (Карьерный трек)\nКарьерный трек представляет из себя модульный проект, который состоит из 8 проектов:\n\nСамоопределение\nРабота мечты\nCV (Резюме)\nИнтервью\nРабота в команде (групповой)\nКорпоративная культура и этика (нормы) работы\nКорпоративная коммуникация\nОбразовательная траектория\nРаньше Карьерный трек представлял из себя модульный проект, расположенный в конце всех проектов Базы: чтобы перейти к вариативным веткам, необходимо было его полностью пройти, но для многих это было уже поздно и неактуально.\n\n\nЧто поменялось?\n\nКарьерное целеполагание и понимание рынка труда необходимы как можно раньше, чтобы можно было более осознанно проектировать свою траекторию развития в рамках обучения. Поэтому первые два проекта карьерного трека стали доступны после прохождения C3. Чтобы перейти к C5 или DO1, теперь нужно завершить эти 2 проекта.\nОставшиеся проекты карьерного трека теперь опциональны с точки зрения обучения, то есть не блокируют продвижение по графу, однако стали обязательными для попадания в канал internship своего кампуса, но об этом ниже.\nДобавлен еще один 8-й проект: Образовательная траектория. Этот проект стал тем самым завершающим элементом Базы. В нем нужно оглянуться на пройденный путь, отрефлексировать его, выявить паттерны и анти-паттерны и сформулировать для себя цели и траекторию на оставшуюся часть графа. Результатом является список проектов, которые необходимо выполнить и которые помогут достичь необходимого уровня для выпуска.\nОсобенность модульного проекта заключается в том, что XP начисляется в самом конце, когда он считается пройден. В связи с тем, что два проекта карьерного трека мы перенесли на более ранний этап, но при этом они в моменте не приносят XP, мы продлили общие дедлайны на набор уровней на 1 неделю. Если пир решает на ранних этапах пройти и другие проекты карьерного трека, то должен учитывать, что может потратить время, а XP в моменте не добрать. На данном этапе по логике обучения пир должен быть больше сфокусирован на образовательном прогрессе.\n\nl) Если я уже прошел C5 или DO1, то нужно ли мне проходить первые два проекта карьерного трека?\nЕсли прошли и C5, и DO1, то вам нужно будет пройти первые два проекта карьерного трека для доступа к новому 8-му проекту карьерного трека, который является финальным для Базы. Если прошли только C5 или только DO1, то для доступа ко второму вам нужно будет пройти эти проекты карьерного трека.\n\n\nm) Если я уже прошел карьерный трек, нужно ли мне снова его проходить?\n\nВесь карьерный трек заново проходить не потребуется. Речь может идти только о 8-м проекте. Это потребуется в случае перехода с одной вариативной ветки на другую, поскольку условием доступа к первому проекту вариативной ветки будет именно этот проект карьерного трека.\nn) Если я нахожусь в процессе прохождения карьерного трека, то что меняется?\nЧасть проектов становятся необязательными для перехода на следующую часть графа. При этом добавляется еще один проект для прохождения. Если хотите попасть в канал стажировок, то в любом случае нужно пройти весь карьерный трек.\n\n\no) Если я уже есть в канале стажировок, меня удалят, если я не соответствую новым критериям?\nНет.\n\n\n\nСтажировка\np) Когда я могу начать проект internship?\nСтажировка стала доступной для валидации в любой момент до начала ее прохождения. Стажировку нельзя валидировать задним числом, если она завершилась или прошло более 1.5 месяца с ее начала.\nЕсли же речь идет о постоянном трудоустройстве, то его можно завалидировать, но это будет идти по стандартному флоу с промежуточной и финальной оценкой от наставника.\n\nq) Могу ли я продлить дедлайн по причине выхода на стажировку?\nПродлить дедлайн можно, если в данный момент ты находишься на проектах Базы. В таком случае после валидации стажировки у тебя есть возможность продлить все дедлайны на время этой стажировки.\n\nУсловия продления:\n\nadm продлевает дедлайн из-за стажировки по запросу на почте.\nВАЖНО! Автоматически продление не происходит;\nдедлайн продлевается на срок, соответствующий дате окончания стажировки.\nПример: ты прислал запрос на продление ддл за 20 дней до окончания стажировки, ддл будет продлен на 20 дней.\nЕсли ты фейлишь стажировку на этапе прохождения Базы, то продление дедлайна на этом заканчивается.\nЕсли после фейла ты снова находишь стажировку во время Базы, то можешь снова запросить новое продление дедлайна в соответствии со сроком ее окончания.\n\nr) Как попасть в канал #internship своего кампуса?\nДоступ в канал #internship своего кампуса и к волнам стажировок Сбера:\n\nлибо завершение мини-экзамена по языковой ветке внутри Базы (в случае изучения Go, это завершение проекта AP2: SmartCalc или BrickGame на Go) + прохождение карьерного трека (проекты 02-07)\nлибо завершение мини-экзаменов по DevOps и SQL + прохождение карьерного трека (проекты 02-07).\nМини-экзамен рассматривается как возможность подготовки к техническому собеседованию. Карьерный трек помогает \"упаковаться\" с точки зрения резюме и сопроводительного письма, а также больше понять контекст работы в корпорациях.\nТакже сделали шаг навстречу тем, кто двигается по треку DevOps, и на которых есть большой спрос у Сбера. У вас появился отдельный трек в этот канал.\n\nШкола изменила правила валидации стажировки и расширила список специальностей. Более подробная информация о процессе прохождения стажировки и критериях валидации находится в этом гайде.\n\n\n\nВыпуск\nСписок образовательных целей по классам\nУказанные в начале FAQ требования необходимы для получения «Основного» сертификата.\nРанее вы могли получить либо «Основной» сертификат, либо «Продвинутый».\nТеперь вы сможете выпуститься на «Основном» сертификате, а потом прокачать его до «Продвинутого»\n\n\ns) Я хочу выпуститься, что делать?\nЕсли ты готов выпуститься и подходишь по критериям - смело жми кнопку “Стать выпускником!” на этой странице\nПосле нажатия кнопки твоя заявка попадет на проверку команде ADM/PIN. Если ты подходишь по всем критериям выпуска и проверка пройдена успешно, тебе будет предложено заполнить анкету выпускника и записаться на встречу-вручение. Встреча может быть с индивидуальным вручением или торжественным выпускным.\nЕсли при проверке окажется, что ты не выполнил один или несколько критериев для выпуска, с тобой свяжется команда ADM/PIN.\n\n\nt) Как получить продвинутый сертификат?\nПосле получения статуса выпускника ты сможешь продолжить обучение и получить сертификат “Освоил программу продвинутого курса”, если:\n\nзавершишь одну из вариативных веток,\nнаберешь 13 уровень.\n\nПри этом не каждая ветка после проектов Базы засчитывается для выпуска с этим сертификатом. Не засчитываются:\n\nветка A\nветка AP\nветка SQL\nветка CPP\nветка C\nОстальные ветки засчитываются за вариативные, поскольку дают понятную для рынка специализацию."
  }
}